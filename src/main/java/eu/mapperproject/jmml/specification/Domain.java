//
// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, vJAXB 2.1.10 in JDK 6 
// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
// Any modifications to this file will be lost upon recompilation of the source schema. 
// Generated on: 2011.08.11 at 05:21:44 PM CEST 
//


package eu.mapperproject.jmml.specification;

import eu.mapperproject.jmml.specification.graph.Child;
import eu.mapperproject.jmml.specification.graph.Numbered;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlType;
import javax.xml.bind.annotation.XmlValue;


/**
 * 
 * 	    A domain and all its super-domains, separated by periods like
 *	      `domain.subdomain.subsubdomain'.
 * 	  
 * 
 * <p>Java class for domain simple type.
 * 
 * <p>The following schema fragment specifies the expected content contained within this class.
 * 
 * <pre>
 * &lt;simpleType name="domain">
 *   &lt;restriction base="{http://www.w3.org/2001/XMLSchema}string">
 *     &lt;pattern value="(\p{Pc}|\p{Pd}|\p{L}|\p{N})+(\.(\p{Pc}|\p{Pd}|\p{L}|\p{N})+)*"/>
 *   &lt;/restriction>
 * &lt;/simpleType>
 * </pre>
 * 
 * 
 */
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "domain", propOrder = {
    "value"
})
public class Domain implements Child<Domain>, Comparable<Domain>, Numbered {
    @XmlValue
    protected String value;

	/** A generic root domain denoting all domains */
	public final static Domain GENERIC = new Domain(0, "GENERIC");
	
    /**
     * 
     * 	    A domain and all its super-domains, separated by periods like
	 *	       `domain.subdomain.subsubdomain'.
     * 	  
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getValue() {
        return value;
    }

    /**
     * Sets the value of the value property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */
    public void setValue(String value) {
        this.value = value;
    }
	private final String name;
	private final Domain parent;
	private final int num;
	
	
	public Domain(int num, String name) {
		this(num, name, null);
	}
	
	private Domain(int num, String name, Domain parent) {
		this.parent = parent;
		this.name = name;
		this.num = num;
	}
	
	/** Create a new domain which is a child of the current domain */
	public Domain getChild(int num, String name) {
		return new Domain(num, name, this);
	}
	
	@Override
	public boolean isRoot() {
		return this.parent == null;
	}
	
	@Override
	public Domain parent() {
		return this.parent;
	}
	
	@Override
	public String toString() {
		if (this.isRoot()) {
			return this.name;
		}
		else {
			return this.parent.toString() + "." + this.name;
		}
	}

	/** Get the name of this single domain */
	public String getName() {
		return this.name;
	}
	
	@Override
	public boolean equals(Object o) {
		if (o == null || getClass() != o.getClass()) return false;
		return this.num == ((Domain)o).num;
	}

	@Override
	public int hashCode() {
		return this.num;
	}
	
	/**
	 * Parse a domain and their parents from a string.
	 * 
	 * The string should be a dot-delimited sequence of domains, first one being the root
	 * @param s parseable string
	 * @param domains a map of previously parsed domains, which can be used as parents. This will be extended with new domains found
	 */
	public static Domain parseDomain(String s, int startNum, Map<String, List<Domain>> domains) {
		String[] ss = s.split("\\.");
		Domain child = Domain.GENERIC, parent = Domain.GENERIC;
		
		for (int i = 0; i < ss.length; i++) {
			child = null;

			// Get all domains that have the same name but might be somewhere else in the hierarchy
			List<Domain> peers = domains.get(ss[i]);
			if (peers == null) {
				peers = new ArrayList<Domain>();
				domains.put(ss[i], peers);
			}

			// Determine which of the namesakes has the same place in the hierarchy
			for (Domain peer : peers) {
				if (!peer.isRoot() && peer.parent().equals(parent)) {
					child = peer;
					break;
				}
			}

			// If it was not found among its namesakes, create a new domain
			if (child == null) {
				child = parent.getChild(startNum++, ss[i]);
				peers.add(child);
			}

			// Proceed to the next level
			parent = child;
		}

		return child;
	}

	@Override
	public int compareTo(Domain t) {
		if (this.num < t.num) return -1;
		else if (this.num > t.num) return 1;
		else return 0;
	}

	@Override
	public int getNumber() {
		return this.num;
	}

	@Override
	public String getId() {
		return Integer.toString(this.num);
	}

	@Override
	public boolean deepEquals(Object o) {
		if (!this.equals(o)) return false;
		Domain other = (Domain)o;
		return this.name.equals(other.name) && (this.parent == null ? other.parent == null : this.parent.equals(other.parent));
	}

}
